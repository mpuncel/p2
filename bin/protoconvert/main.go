package main

import (
	"fmt"
	"go/ast"
	"go/build"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"log"
	"path/filepath"

	"gopkg.in/alecthomas/kingpin.v2"
)

var (
	fromPkgPath   = kingpin.Flag("from-pkg", "The package containing the type to convert from, e.g. github.com/square/p2/pkg/grpc/daemonsetstore/protos").Required().String()
	fromTypeName  = kingpin.Flag("from-type", "The type name to convert from, e.g. DaemonSet").Required().String()
	outputPackage = kingpin.Flag("output-pkg", "The package into which conversion code should be written").Required().String()
	toPkgPath     = kingpin.Flag("to-pkg", "The package containing the type to convert to, e.g. github.com/square/p2/pkg/ds/fields.DaemonSet").Required().String()
	toTypeName    = kingpin.Flag("to-type", "Tye type name to convert to, e.g. DaemonSet").Required().String()
)

func main() {
	_ = kingpin.Parse()

	fmt.Printf("converting from %s.%s to %s.%s\n", *fromPkgPath, *fromTypeName, *toPkgPath, *toTypeName)

	fset := token.NewFileSet()

	// import the from package to identify all of the .go files it has
	fromBuildPkg, err := build.Default.Import(*fromPkgPath, "", 0)
	if err != nil {
		log.Fatal(err)
	}

	fileWithFromType, fromType, err := findType(*fromTypeName, fromBuildPkg, fset)
	if err != nil {
		log.Fatal(err)
	}

	// import the from package to identify all of the .go files it has
	toBuildPkg, err := build.Default.Import(*toPkgPath, "", 0)
	if err != nil {
		log.Fatal(err)
	}

	fileWithToType, toType, err := findType(*toTypeName, toBuildPkg, fset)
	if err != nil {
		log.Fatal(err)
	}

	conf := types.Config{
		Importer: importer.Default(),
	}

	fromInfo := types.Info{
		Types: make(map[ast.Expr]types.TypeAndValue),
	}

	_, err = conf.Check(*fromPkgPath, fset, []*ast.File{fileWithFromType}, &fromInfo)
	if err != nil {
		log.Fatalf("conf check: %s", err)
	}

	toInfo := types.Info{
		Types: make(map[ast.Expr]types.TypeAndValue),
	}

	_, err = conf.Check(*toPkgPath, fset, []*ast.File{fileWithToType}, &toInfo)
	if err != nil {
		log.Fatalf("conf check: %s", err)
	}

	fmt.Printf("%s.%s info:\n", *fromPkgPath, *fromTypeName)
	for _, field := range fromType.Fields.List {
		fmt.Printf("%s %s %s\n", field.Names[0], field.Type, fromInfo.TypeOf(field.Type))
	}

	fmt.Printf("\n%s.%s info:\n", *toPkgPath, *toTypeName)
	for _, field := range toType.Fields.List {
		fmt.Printf("%s %s %s\n", field.Names[0], field.Type, toInfo.TypeOf(field.Type))
	}

	fileBytes, err := generateConversions(fromType, toType)
	if err != nil {
		log.Fatalf("could not generate type conversions: %s", err)
	}

	fmt.Println(string(fileBytes))
}

func findType(typeName string, buildPkg *build.Package, fset *token.FileSet) (*ast.File, *ast.StructType, error) {
	// parse all files in the "from package" and look for the "from type"
	for _, file := range buildPkg.GoFiles {
		f, err := parser.ParseFile(fset, filepath.Join(buildPkg.Dir, file), nil, 0)
		if err != nil {
			continue
		}

		for _, decl := range f.Decls {
			decl, ok := decl.(*ast.GenDecl)
			if !ok || decl.Tok != token.TYPE {
				continue
			}
			for _, spec := range decl.Specs {
				spec := spec.(*ast.TypeSpec)
				if spec.Name.Name != *fromTypeName {
					continue
				}

				// cast the "from type" to a struct so we can get the fields
				structType, ok := spec.Type.(*ast.StructType)
				if !ok {
					return nil, nil, fmt.Errorf("%s was not a struct", typeName)
				}

				return f, structType, nil
			}
		}
	}

	return nil, nil, fmt.Errorf("type %s not found", typeName)
}

func generateConversions(fromType *ast.StructType, toType *ast.StructType) ([]byte, error) {
	var bytes []byte
	bytes = append(bytes, []byte("// Code generated by protoconvert; DO NOT EDIT.\n\n")...)
	bytes = append(bytes, []byte(fmt.Sprintf("package %s\n\n", *outputPackage))...)
	return nil, nil
}
